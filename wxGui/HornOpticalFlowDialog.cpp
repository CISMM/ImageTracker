// -*- C++ -*- generated by wxGlade 0.6.3 on Sat Aug  2 12:28:09 2008

#include "HornOpticalFlowDialog.h"

// begin wxGlade: ::extracode

// end wxGlade

#include "FileUtils.h"
#include "ImageTrackerController.h"
#include "Logger.h"
#include "PipelineExecutor.h"
#include "wxUtils.h"

HornOpticalFlowDialog::HornOpticalFlowDialog(wxWindow* parent, int id, const wxString& title, const wxPoint& pos, const wxSize& size, long style):
    wxDialog(parent, id, title, pos, size, wxDEFAULT_DIALOG_STYLE|wxRESIZE_BORDER|wxTHICK_FRAME)
{
    // begin wxGlade: HornOpticalFlowDialog::HornOpticalFlowDialog
    sizer_36_staticbox = new wxStaticBox(this, -1, wxT("Output"));
    sizer_35_staticbox = new wxStaticBox(this, -1, wxT("Parameters"));
    label_28 = new wxStaticText(this, wxID_ANY, wxT("Derivative Scale"));
    slideDerivativeScale = new wxDoubleSlider(this, wxID_ANY);
    label_29 = new wxStaticText(this, wxID_ANY, wxT("Regularization"));
    slideRegularization = new wxDoubleSlider(this, wxID_ANY);
    label_30 = new wxStaticText(this, wxID_ANY, wxT("Iterations"));
    slideIterations = new wxIntSlider(this, wxID_ANY);
    panelFilePattern = new FilePatternPanel(this, wxID_ANY);
    checkOpenOutput = new wxCheckBox(this, wxID_ANY, wxT("Open output when done"));
    buttonRun = new wxButton(this, wxID_OK, wxT("&Run"));
    buttonHide = new wxButton(this, wxID_CANCEL, wxT("&Hide"));

    set_properties();
    do_layout();
    // end wxGlade
    
    //-- Custom code --//
    // setup process objects
    this->input = NULL;
    this->pipeline = HornOpticalFlowPipeline::New();
    
    // setup sliders
    this->slideDerivativeScale->SetRange(0.5, 24.0, 0.1);
    this->slideDerivativeScale->SetFormat("%0.02f");
    this->slideRegularization->SetRange(1.0, 4000.0, 1.0);
    this->slideRegularization->SetFormat("%0.02f");
    this->slideIterations->SetRange(200, 4000);
    
    this->panelFilePattern->SetRangeEnabled(false);
    this->panelFilePattern->SetExtensionEnabled(false);
}


BEGIN_EVENT_TABLE(HornOpticalFlowDialog, wxDialog)
    // begin wxGlade: HornOpticalFlowDialog::event_table
    EVT_BUTTON(wxID_OK, HornOpticalFlowDialog::OnRun)
    EVT_BUTTON(wxID_CANCEL, HornOpticalFlowDialog::OnHide)
    // end wxGlade
END_EVENT_TABLE();


void HornOpticalFlowDialog::OnRun(wxCommandEvent &event)
{
    event.Skip();
}


void HornOpticalFlowDialog::OnHide(wxCommandEvent &event)
{
    event.Skip();
}


// wxGlade: add HornOpticalFlowDialog event handlers


void HornOpticalFlowDialog::set_properties()
{
    // begin wxGlade: HornOpticalFlowDialog::set_properties
    SetTitle(wxT("Horn & Schunck Optical Flow"));
    slideDerivativeScale->SetToolTip(wxT("Scale to use for computing spatial image derivatives"));
    slideRegularization->SetToolTip(wxT("A higher value enforces a smoother optical flow field"));
    slideIterations->SetToolTip(wxT("Number of iterations to perform on each image pair"));
    checkOpenOutput->SetToolTip(wxT("Indicates whether ImageTracker should open the output files when finished"));
    checkOpenOutput->SetValue(1);
    buttonRun->SetToolTip(wxT("Execute the optical flow algorithm"));
    buttonHide->SetToolTip(wxT("Hide this dialog without executing"));
    // end wxGlade
}


void HornOpticalFlowDialog::do_layout()
{
    // begin wxGlade: HornOpticalFlowDialog::do_layout
    wxBoxSizer* sizer_34 = new wxBoxSizer(wxVERTICAL);
    wxBoxSizer* sizer_37 = new wxBoxSizer(wxHORIZONTAL);
    wxStaticBoxSizer* sizer_36 = new wxStaticBoxSizer(sizer_36_staticbox, wxVERTICAL);
    wxFlexGridSizer* grid_sizer_12 = new wxFlexGridSizer(1, 2, 5, 5);
    wxStaticBoxSizer* sizer_35 = new wxStaticBoxSizer(sizer_35_staticbox, wxVERTICAL);
    wxFlexGridSizer* grid_sizer_11 = new wxFlexGridSizer(3, 2, 5, 5);
    grid_sizer_11->Add(label_28, 0, 0, 0);
    grid_sizer_11->Add(slideDerivativeScale, 0, wxEXPAND, 0);
    grid_sizer_11->Add(label_29, 0, 0, 0);
    grid_sizer_11->Add(slideRegularization, 1, wxEXPAND, 0);
    grid_sizer_11->Add(label_30, 0, 0, 0);
    grid_sizer_11->Add(slideIterations, 1, wxEXPAND, 0);
    grid_sizer_11->AddGrowableCol(1);
    sizer_35->Add(grid_sizer_11, 0, wxEXPAND, 0);
    sizer_34->Add(sizer_35, 0, wxEXPAND, 0);
    sizer_36->Add(panelFilePattern, 0, wxEXPAND, 0);
    grid_sizer_12->Add(110, 20, 0, 0, 0);
    grid_sizer_12->Add(checkOpenOutput, 0, 0, 0);
    grid_sizer_12->AddGrowableCol(1);
    sizer_36->Add(grid_sizer_12, 1, wxEXPAND, 0);
    sizer_34->Add(sizer_36, 1, wxEXPAND, 0);
    sizer_37->Add(buttonRun, 0, 0, 0);
    sizer_37->Add(buttonHide, 0, 0, 0);
    sizer_34->Add(sizer_37, 0, wxALIGN_CENTER_HORIZONTAL, 0);
    SetSizer(sizer_34);
    sizer_34->Fit(this);
    Layout();
    // end wxGlade
}


void HornOpticalFlowDialog::SetInput(ImageFileSet* input)
{
    this->input = input;
    this->pipeline->SetInput(this->input);
}

bool HornOpticalFlowDialog::TransferDataToWindow()
{
    this->slideDerivativeScale->SetValue(this->pipeline->GetSpatialSigma());
    this->slideRegularization->SetValue(this->pipeline->GetSmoothWeighting());
    this->slideIterations->SetValue(this->pipeline->GetIterations());
    
    // create a default output file pattern
    std::string dir(nano::wx2std(wxGetCwd()));
    CapDirectory(dir);
    std::string format("horn-%04d.mha");
    std::string example = ImageTrackerController::Instance()->GetImageFiles()[0];    
    unsigned int start = NumberPart(example);
    unsigned int end = start + this->input->GetImageCount() - 2;
    this->panelFilePattern->SetFilePattern(FilePattern(dir, format, start, end));
    this->panelFilePattern->TransferDataToWindow();
    
    return true;
}

bool HornOpticalFlowDialog::TransferDataFromWindow()
{
    std::string function("HornOpticalFlowDialog::TransferDataFromWindow");
    this->pipeline->SetSpatialSigma(this->slideDerivativeScale->GetValue());
    this->pipeline->SetSmoothWeighting(this->slideRegularization->GetValue());
    this->pipeline->SetIterations(this->slideIterations->GetValue());
    
    FileSet outFiles(this->panelFilePattern->GetFilePattern());
    this->pipeline->SetOutputFiles(outFiles);
    
    // Create and launch a pipeline executor (uses another thread)
    PipelineExecutor* exec = new PipelineExecutor(this->pipeline);
    exec->SetOpenFiles(this->checkOpenOutput->IsChecked());
    exec->SetImageResult(false);
    if (exec->Create() == wxTHREAD_NO_ERROR)
    {
        exec->Run();
    }
    else
    {
        Logger::warning << function << ": Unable to create threaded pipeline execution object." << std::endl;
        delete exec;
    }
    
    return true;
}